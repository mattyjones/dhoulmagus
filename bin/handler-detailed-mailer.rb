#! /usr/bin/env ruby

require 'sensu-handler'
require 'dhoulmagus/version'
require 'mail'
require 'timeout'
require 'socket'
require 'erb'

# patch to fix Exim delivery_method: https://github.com/mikel/mail/pull/546
# @since 0.0.1
module ::Mail
  class Exim < Sendmail
    def self.call(path, arguments, _destinations, encoded_message)
      popen "#{path} #{arguments}" do |io|
        io.puts encoded_message.to_lf
        io.flush
      end
    end
  end
end

# Create a well formed universal html email message using json and erb templates
#
# @since 0.0.1
class DetailedMailer < Sensu::Handler
  # Acquires the mail settings from a json file dropped via Chef
  #
  # These settings will set who the mail should be set to along with any
  # necessary snmtp settings.  All can be overridden in the local Vagrantfile
  #
  # @example Get a setting
  #   "acquire_setting('alert_prefix')" #=> "go away"
  # @param name [string] the alert heading
  # @return [string] the configuration string
  def acquire_setting(name)
    product = ARGV[0]
    settings[product][name]
  end

  def clean_output
    @event['check']['output'].partition(':')[0]
  end

  # Acquire any client or device specific information about the
  # monitoring infrastructure
  #
  # @example Get the information
  #   "acquire_infra_details" #=> Hash
  # @return [hash] any provided infra details for the device
  def acquire_infra_details
    JSON.parse(File.read('/etc/sensu/conf.d/monitoring_infra.json'))
  end

  # Calculate the duration the check has been it its current state
  # @example Get how long a check has been in a give state
  #   "define_check_state_duration" #=> ""
  # @return [string] the length of time a check has been in its current state
  def define_check_state_duration
    ''
  end

  # Define a short name for the alert to be used in log files
  #
  # This will be used in log files to track the execution of the mailer
  # It can currently be found in `/var/log/sensu/sensu-server.log`
  #
  # @example Get a string with the name and check in it
  #   "short_name" #=> "dev-foo/cpu-load"
  # @return [string] a string consisting of the device being alerted on and the check name
  def short_name
    "#{@sensu_config['monitored_instance']}/#{@sensu_config['check_name']}"
  end

  # Define the type of alert this is
  #
  # This will be used in both the email subject and in the `Notification Type:` field
  #
  # @example Set the notification type to FLAPPING
  #   "define_notification_type" #=> "FLAPPING
  # @return [string] the notification type
  def define_notification_type
    case @event['action']
    when 'resolve'
      return 'CLEAR'
    when 'create'
      return 'ALERT'
    when 'flapping'
      return 'FLAPPING'
    else
      return 'NOTICE'
    end
  end

  # Convert the integer value given by Sensu into a text string
  #
  # This will be used in both the email subject and in the `Check State:` field
  #
  # @example Set the status of the check to WARNING
  #   "define_status" #=> "WARNING
  # @return [string] The status of the check
  def define_status(event)
    case event
    when 0
      return 'OK'
    when 1
      return 'WARNING'
    when 2
      return 'CRITICAL'
    when 3
      return 'UNKNOWN'
    when 127
      return 'CONFIG ERROR'
    when 126
      return 'PERMISSION DENIED'
    else
      return 'ERROR'
    end
  end

  # Define the operating environment of the device being monitored
  #
  # This is not where the server is located, but where the client is located.
  # The client could be sending its checks to any regin/cluster/env so we need
  # to know where the actual device is located
  #
  # @example Set the sensu environment to Dev:
  #   "define_sensu_env" #=> "Dev: '"
  # @return [string] The environemnt the client is associated with
  def define_sensu_env
    case acquire_infra_details['sensu']['environment']
    when 'prd'
      return 'Prod: '
    when 'dev'
      return 'Dev: '
    when 'stg'
      return 'Stg: '
    when 'vagrant'
      return 'Vagrant: '
    else
      return 'Test: '
    end
  end

  # Define the source of the email
  #
  # The email could be generated by any number of applications using its api,
  # each application needs to be defined here for filtering purposes
  #
  # @example Set the source application to sensu
  #   "define_source" #=> "sensu"
  # @return [string] The application interacting with the mailer
  def define_source
    'sensu'
  end

  def check_data
    ''
  end

  def acquire_alerts
    out = api_request(:GET, "/events/#{@event['client']['name']}")

    alerts = {}
    JSON.parse(out.body).each do |a|
      alerts[a['check']['name']] = define_status(a['check']['status'])
    end
    alerts.sort
  end

  def acquire_monitored_instance
    @event['client']['name']
  end

  # Define all erb template variables
  #
  # This will determine what values to calculate for the templates
  #
  # @param source [string] the source application
  # @example Create the template var hash
  #   "template_vars(sensu)" #=> "@sensu_config"
  # @return [hash] All values to be dropped into the email template
  def template_vars(source)
    case source
    when 'sensu'
      @sensu_config = {
        'monitored_instance'    => acquire_monitored_instance, # this will be the snmp host if using traps
        'sensu_client'          => @event['client']['name'],
        'incident_timestamp'    => Time.at(@event['check']['issued']),
        'instance_address'      => @event['client']['address'],
        'check_name'            => @event['check']['name'],
        'check_state'           => define_status(@event['check']['status']),
        'check_data'            => check_data, # any additional user supplied data
        'notification_comment'  => '', # the comment added to a check to silence it
        'notification_author'   => '', # the user that silenced the check
        'check_output'          => clean_output,
        'sensu_env'             => define_sensu_env,
        'notification_type'     => define_notification_type,
        'check_state_duration'  => define_check_state_duration,
        'mail_template'         => "#{@template_path}/sensu/sensu_alert_email.erb",
        'additional_alerts'     => acquire_alerts
      }
      @mail_subject = "#{define_sensu_env} #{define_notification_type}  #{@sensu_config['check_name']} on #{@sensu_config['monitored_instance']} is #{@sensu_config['check_state']}"
    end
  end

  # Create the email and ship it
  # @example Set the notification type to CRITICAL
  #   "handle" #=> "A well-formed email notification to a recipent"
  # @return [integer] exit code
  def handle
    ######################
    #                    #
    # smtp mail settings #
    #                    #
    ######################
    mail_to                   = acquire_setting('mail_to')
    mail_from                 = acquire_setting('mail_from')

    delivery_method           = acquire_setting('delivery_method') || 'smtp'
    smtp_address              = acquire_setting('smtp_address') || 'localhost'
    smtp_port                 = acquire_setting('smtp_port') || '25'
    smtp_domain               = acquire_setting('smtp_domain') || 'localhost.localdomain'

    smtp_username             = acquire_setting('smtp_username') || nil
    smtp_password             = acquire_setting('smtp_password') || nil
    smtp_authentication       = acquire_setting('smtp_authentication') || :plain
    smtp_enable_starttls_auto = acquire_setting('smtp_enable_starttls_auto') == 'false' ? false : true

    # set the source application to define the proper template variables
    source = define_source

    ###################################
    #                                 #
    # create and render the email msg #
    #                                 #
    ###################################
    gem_base = `/opt/sensu/embedded/bin/gem environment gemdir`.gsub("\n", '')
    @template_path = "#{gem_base}/gems/dhoulmagus-#{Dhoulmagus::Version::STRING}/templates"
    template_vars(source)
    renderer = ERB.new(File.read(@sensu_config['mail_template']))
    msg = renderer.result(binding)
    mail_subject = "#{define_sensu_env} #{define_notification_type}  #{@sensu_config['check_name']} on #{@sensu_config['monitored_instance']} is #{@sensu_config['check_state']}"

    #####################################
    #                                   #
    # deliver the email and log it to   #
    # /var/log/sensu/sensu-server       #
    #                                   #
    #####################################
    Mail.defaults do
      delivery_options = {
        address: smtp_address,
        port: smtp_port,
        domain: smtp_domain,
        openssl_verify_mode: 'none',
        enable_starttls_auto: smtp_enable_starttls_auto
      }

      unless smtp_username.nil?
        auth_options = {
          user_name: smtp_username,
          password: smtp_password,
          authentication: smtp_authentication
        }
        delivery_options.merge! auth_options
      end

      delivery_method delivery_method.intern, delivery_options
    end

    begin
      timeout 10 do
        Mail.deliver do
          to mail_to
          from mail_from
          subject mail_subject
          content_type 'text/html; charset=UTF-8'
          body msg
        end

        puts 'mail -- sent alert for ' + short_name + ' to ' + mail_to.to_s
      end
    rescue Timeout::Error
      puts 'mail -- timed out while attempting to ' + define_notification_type + ' an incident -- ' + short_name
    end
  end
end
